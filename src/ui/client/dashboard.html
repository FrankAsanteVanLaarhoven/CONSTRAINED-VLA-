<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAFETY-TRANSFER | Holodeck OS</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap');

        :root {
            --bg-dark: #050505;
            --panel-bg: rgba(20, 20, 25, 0.65);
            --border: rgba(255, 255, 255, 0.1);
            --accent: #00f2ff;
            --warning: #ffcc00;
            --danger: #ff2a6d;
            --success: #00ff9d;
            --grid-color: rgba(0, 242, 255, 0.05);
            --glass-blur: 20px;
        }

        body {
            margin: 0;
            background-color: var(--bg-dark);
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(0, 242, 255, 0.05) 0%, transparent 60%),
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 100% 100%, 40px 40px, 40px 40px;
            color: #eee;
            font-family: 'Inter', sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            perspective: 2000px; /* For 4D Depth */
        }

        /* --- HEADER --- */
        header {
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 30px;
            border-bottom: 1px solid var(--border);
            background: rgba(5, 5, 5, 0.9);
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        .brand {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            letter-spacing: 2px;
            color: var(--accent);
            text-shadow: 0 0 15px var(--accent);
        }
        .controls button {
            background: transparent;
            border: 1px solid var(--border);
            color: #aaa;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'JetBrains Mono';
            font-size: 0.8rem;
        }
        .controls button:hover {
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.2);
        }

        /* --- STAGE MANAGER (Sidebar) --- */
        #stage-manager {
            position: fixed;
            left: 0;
            top: 60px;
            bottom: 0;
            width: 60px;
            background: rgba(0,0,0,0.4);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            transition: width 0.3s ease;
            z-index: 900;
        }
        #stage-manager:hover { width: 250px; background: rgba(0,0,0,0.8); }
        #stage-manager .dock-item {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 1px solid var(--border);
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            transition: all 0.2s;
            color: #555;
        }
        #stage-manager:hover .dock-item {
            width: 90%;
            justify-content: flex-start;
            padding-left: 15px;
            color: #eee;
        }
        #stage-manager:hover .dock-item:after {
            content: attr(data-label);
            margin-left: 10px;
            font-family: 'JetBrains Mono';
            font-size: 0.8rem;
        }

        /* --- MAIN GRID LAYOUT --- */
        #workspace {
            flex: 1;
            margin-left: 60px; /* Offset for Stage Manager */
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(12, 1fr);
            gap: 15px;
            transform-style: preserve-3d;
            height: calc(100vh - 80px); /* Leave room for header */
        }

        /* --- DRAGGABLE PANELS --- */
        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 16px;
            backdrop-filter: blur(var(--glass-blur));
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
            position: relative;
        }
        
        .panel:hover {
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 15px 40px rgba(0,0,0,0.7);
        }

        /* Visual State when Dragging */
        .panel.dragging {
            opacity: 0.5;
            transform: scale(0.95);
            border: 1px dashed var(--accent);
            cursor: grabbing;
        }

        .panel-header {
            padding: 10px 15px;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #888;
            border-bottom: 1px solid var(--border);
            cursor: grab; /* The Handle */
            display: flex;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.02);
            user-select: none;
        }
        .panel-header:active { cursor: grabbing; }

        .panel-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            position: relative;
        }

        /* --- WIDGET CONTENT STYLES --- */
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-family: 'JetBrains Mono';
            font-size: 0.9rem;
        }
        .metric-val { color: var(--accent); font-weight: bold; }
        
        /* 3D Viewport in Panel */
        #mini-viewport {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: radial-gradient(circle, #1a1a25 0%, #000 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .holo-model {
            width: 50px;
            height: 80px;
            border: 1px solid var(--accent);
            box-shadow: 0 0 15px var(--accent);
            animation: holoSpin 8s infinite linear;
        }

        /* --- LOGS --- */
        .log-line { font-family: 'JetBrains Mono'; font-size: 0.7rem; margin-bottom: 4px; opacity: 0.7; }

        /* --- EPHEMERAL OVERLAY (Integrated) --- */
        #ephemeral-overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background: rgba(0,0,0,0.9);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 20px;
            display: none;
            z-index: 2000;
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.3);
        }
        #ephemeral-overlay.active { display: block; animation: popIn 0.3s; }

        @keyframes holoSpin { 0% { transform: rotateY(0deg); } 100% { transform: rotateY(360deg); } }
        @keyframes popIn { from { opacity: 0; transform: translate(-50%, -40%); } to { opacity: 1; transform: translate(-50%, -50%); } }

    </style>
</head>
<body>

    <header>
        <div class="brand">HOLODECK <span style="color:#555">v2.0</span></div>
        <div class="controls">
            <button onclick="resetLayout()">[ RESET LAYOUT ]</button>
            <button onclick="triggerVoice()">[ VOICE CMD ]</button>
        </div>
    </header>

    <!-- SIDEBAR / STAGE MANAGER -->
    <div id="stage-manager">
        <div class="dock-item" draggable="true" ondragstart="dragStartNew(event, 'telemetry')" data-label="Telemetry">T</div>
        <div class="dock-item" draggable="true" ondragstart="dragStartNew(event, 'viewport')" data-label="3D View">V</div>
        <div class="dock-item" draggable="true" ondragstart="dragStartNew(event, 'logs')" data-label="Sys Logs">L</div>
        <div class="dock-item" draggable="true" ondragstart="dragStartNew(event, 'energy')" data-label="Energy">E</div>
    </div>

    <!-- MAIN WORKSPACE (Grid) -->
    <div id="workspace" ondragover="allowDrop(event)" ondrop="drop(event)">
        <!-- Panels injected here by Layout Engine -->
    </div>

    <!-- HIDDEN TEMPLATES -->
    <template id="tpl-telemetry">
        <div class="metric-row"><span>Temp</span><span class="metric-val" id="val-temp">42Â°C</span></div>
        <div class="metric-row"><span>Ping</span><span class="metric-val">12ms</span></div>
        <div class="metric-row"><span>Risk</span><span class="metric-val" style="color:var(--success)">LOW</span></div>
    </template>

    <template id="tpl-viewport">
        <div id="mini-viewport">
            <div class="holo-model"></div>
            <!-- Ephemeral UI anchors here -->
            <div id="ephemeral-overlay">
                <h4 style="margin:0 0 10px 0; color:var(--accent)">INTENT DETECTED</h4>
                <div id="e-widgets"></div>
                <div id="e-avatar" style="margin-top:10px; font-style:italic; color:#888;"></div>
            </div>
        </div>
    </template>

    <template id="tpl-logs">
        <div id="log-container" style="height:100%">
            <div class="log-line">[SYS] Boot Sequence Complete</div>
            <div class="log-line">[NET] Uplink Established</div>
        </div>
    </template>

    <script>
        // --- LAYOUT ENGINE with Persistence ---
        const DEFAULT_LAYOUT = [
            { id: 'p1', type: 'telemetry', x: 1, y: 1, w: 3, h: 5 },
            { id: 'p2', type: 'viewport',  x: 5, y: 1, w: 5, h: 8 },
            { id: 'p3', type: 'logs',      x: 10, y: 1, w: 3, h: 12 },
            { id: 'p4', type: 'energy',    x: 1, y: 7, w: 3, h: 4 }
        ];

        let currentLayout = [];
        const workspace = document.getElementById('workspace');

        function init() {
            const saved = localStorage.getItem('holodeck_layout');
            if (saved) {
                currentLayout = JSON.parse(saved);
            } else {
                currentLayout = JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
            }
            renderLayout();
            startLoops();
        }

        function renderLayout() {
            workspace.innerHTML = '';
            currentLayout.forEach(item => {
                createPanelDOM(item);
            });
        }

        function createPanelDOM(item) {
            const panel = document.createElement('div');
            panel.className = 'panel';
            panel.id = item.id;
            panel.draggable = true;
            
            // Grid Positioning
            panel.style.gridColumnStart = item.x;
            panel.style.gridColumnEnd = item.x + item.w;
            panel.style.gridRowStart = item.y;
            panel.style.gridRowEnd = item.y + item.h;

            // Header
            const header = document.createElement('div');
            header.className = 'panel-header';
            header.innerHTML = `<span>${item.type.toUpperCase()}</span> <span style="cursor:pointer" onclick="closePanel('${item.id}')">Ã—</span>`;
            panel.appendChild(header);

            // Drag Events
            panel.addEventListener('dragstart', (e) => dragStartPanel(e, item.id));

            // Content
            const content = document.createElement('div');
            content.className = 'panel-content';
            
            // Inject Template content
            const tpl = document.getElementById(`tpl-${item.type}`);
            if (tpl) {
                content.appendChild(tpl.content.cloneNode(true));
            } else {
                content.innerHTML = `<div style="text-align:center; padding-top:20px; color:#555">[ ${item.type} ]</div>`;
            }
            
            panel.appendChild(content);
            workspace.appendChild(panel);
        }

        // --- DRAG & DROP LOGIC ---
        let draggedId = null;
        let isNewItem = false;
        let newType = null;

        function dragStartPanel(e, id) {
            draggedId = id;
            isNewItem = false;
            e.dataTransfer.effectAllowed = "move";
            e.target.classList.add('dragging');
        }

        function dragStartNew(e, type) {
            isNewItem = true;
            newType = type;
            e.dataTransfer.effectAllowed = "copy";
        }

        function allowDrop(e) {
            e.preventDefault();
        }

        function drop(e) {
            e.preventDefault();
            
            // Calculate Grid Pos
            const rect = workspace.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 12 columns, 12 rows logic approx
            const colW = rect.width / 12;
            const rowH = rect.height / 12;
            
            let gridX = Math.ceil(x / colW);
            let gridY = Math.ceil(y / rowH);
            if (gridX < 1) gridX = 1; if (gridX > 12) gridX = 12;
            if (gridY < 1) gridY = 1; if (gridY > 12) gridY = 12;

            if (isNewItem) {
                // Add new panel
                const newId = 'p_' + Date.now();
                currentLayout.push({
                    id: newId,
                    type: newType,
                    x: gridX, y: gridY,
                    w: 3, h: 4 // Default size
                });
            } else {
                // Move existing panel
                const item = currentLayout.find(i => i.id === draggedId);
                if (item) {
                    item.x = gridX;
                    item.y = gridY;
                    document.getElementById(draggedId).classList.remove('dragging');
                }
            }
            
            saveAndRender();
        }

        function closePanel(id) {
            currentLayout = currentLayout.filter(i => i.id !== id);
            saveAndRender();
        }

        function resetLayout() {
            currentLayout = JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
            saveAndRender();
            // Also notify server via WS if needed, but local is enough for UI
        }

        function saveAndRender() {
            localStorage.setItem('holodeck_layout', JSON.stringify(currentLayout));
            renderLayout();
        }

        // --- SIMULATION & WEBSOCKETS ---
        const ws = new WebSocket(`ws://${location.host}/ws`);
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if(data.type === 'UI_UPDATE') {
                showEphemeral(data.config, data.avatar);
            } else if (data.type === 'UI_CLEAR') {
                hideEphemeral();
            } else if (data.type === 'RESET_LAYOUT') {
                resetLayout(); // Triggered by Voice
            }
        };

        function showEphemeral(config, avatar) {
            const el = document.getElementById('ephemeral-overlay');
            const widgets = document.getElementById('e-widgets');
            const av = document.getElementById('e-avatar');
            
            if(!el) return; // Might be hidden if Viewport panel closed
            
            widgets.innerHTML = '';
            config.widgets.forEach(w => {
                 widgets.innerHTML += `<div style="margin-bottom:8px; font-size:0.8rem; color:#ccc">${w.label}</div>`;
            });
             
            av.innerText = `AVATAR: ${avatar.speech}`;
            el.classList.add('active');
        }
        
        function hideEphemeral() {
            const el = document.getElementById('ephemeral-overlay');
            if(el) el.classList.remove('active');
        }

        function startLoops() {
            setInterval(() => {
                const el = document.getElementById('val-temp');
                if(el) el.innerText = (40 + Math.random()*2).toFixed(1) + "Â°C";
            }, 1000);
        }

        // --- GESTURE CONTROL (Air Interface) ---
        let video = null;
        let prevFrame = null;
        
        // Add Webcam View to Sidebar Dock
        const camView = document.createElement('div');
        camView.className = 'dock-item';
        camView.innerHTML = 'ðŸ“·';
        camView.title = 'Enable Gestures';
        camView.onclick = enableGestures;
        document.getElementById('stage-manager').appendChild(camView);

        async function enableGestures() {
            log("[GESTURE] Initializing Camera...");
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 64, height: 64 } });
                
                // Create minimal video element
                video = document.createElement('video');
                video.width = 64; video.height = 64;
                video.srcObject = stream;
                video.play();
                
                // Create processing canvas
                const cvs = document.createElement('canvas');
                cvs.width = 64; cvs.height = 64;
                const ctx = cvs.getContext('2d');
                
                log("[GESTURE] Active. Waving hand triggers RESET.", "success");
                
                // Motion Loop
                setInterval(() => {
                    ctx.drawImage(video, 0, 0, 64, 64);
                    const frame = ctx.getImageData(0, 0, 64, 64);
                    if (prevFrame) {
                        const diff = calculateMotion(prevFrame.data, frame.data);
                        if (diff > 3000) { // Threshold
                             log("[GESTURE] MOTION DETECTED: RESET!");
                             resetLayout(); 
                             // Debounce
                             prevFrame = null; 
                             return; 
                        }
                    }
                    prevFrame = frame;
                }, 200); // 5Hz Check
                
            } catch(e) {
                log("[GESTURE] Camera Denied: " + e);
            }
        }

        function calculateMotion(oldData, newData) {
            let score = 0;
            for (let i = 0; i < oldData.length; i += 4) {
                score += Math.abs(oldData[i] - newData[i]);
            }
            return score / 100; // Normalize
        }

        init();
    </script>
</body>
</html>
